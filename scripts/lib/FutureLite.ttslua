--[[--
Future Lite API
Barebones future API for TTS with no other dependencies.
@module FutureLite
@author Rob Bartlett-Schneider / Tullisar
@revision 1.0
@license Apache2
@copyright 2021 Rob Bartlett-Schneider
--]]

local NAME = "FutureLite"
local VERSION_STRING = "1.0"
local VERSION = 1.0
local GLOBAL_PATH = NAME
local FutureLite = _G[GLOBAL_PATH]

-- Check to see if FutureLite has been globalized with the same or a newer
-- version than the current.
if (FutureLite and (FutureLite.VERSION >= VERSION)) then
  return FutureLite
end

-- Create a new table for the library.
FutureLite = {
  NAME = NAME,
  VERSION_STRING = VERSIONSTRING,
  VERSION = VERSION,
  DEFAULT_TIMEOUT = 60,
  dispatch = Wait.condition,
}

-- =============================================================================
-- Local Lua API Aliases
-- =============================================================================
local type, pairs, table, string = _G.type, _G.pairs, _G.table, _G.string
local assert, error, xpcall, select = _G.assert, _G.error, _G.xpcall, _G.select
local setmetatable, getmetatable = _G.setmetatable, _G.getmetatable

-- =============================================================================
-- Local functions
-- These are not exposed in any way to users of the FutureLite library.
-- =============================================================================

--------------------------------------------------------------------------------
-- Installs bare-bones class features on a given table
-- Add indexing and call metamethods to the class's metatable (using the
-- existing metatable if present)
--------------------------------------------------------------------------------
local function __class()
  local class = {}
  return setmetatable(class, {
    __index    = class,
    __call     = (|c, ...| setmetatable(c:__new(...), c)),
    isInstance = (|c, o| (getmetatable(o) == class))
  })
end

--------------------------------------------------------------------------------
-- Returns an iterator that can be used safely over a vararg list, including
-- all nil values.
--------------------------------------------------------------------------------
local function __iterateArgs(...)
  local iterator = {args = table.pack(...), index = 0}
  function iterator:next()
    self.index = self.index + 1
    if (self.index <= self.args.n) then
      return self.index, self.args[self.index]
    end
    return nil
  end
  return setmetatable(iterator, { __call = iterator.next })
end

--------------------------------------------------------------------------------
-- Throws an error that indicates the given value is not a callable object
--------------------------------------------------------------------------------
local function __notCallable(value)
  error(string.format("'%s' is not a Callable object.", tostring(value)))
end

--------------------------------------------------------------------------------
-- Throws an error that indicates the given value is not a callable object
--------------------------------------------------------------------------------
local function __notModifiable(object, ...)
  error(string.format("'%s' cannot be direcftly modified.", tostring(object)))
end

-- =============================================================================
-- Public functions
-- These are not exposed in any way to users of the FutureLite library.
-- =============================================================================

--[[--
@TODO(tullisar)
<summary>
<description>
@function FutureLite:globalize
--]]
function FutureLite:globalize()
  local __FutureLite = _G[GLOBAL_PATH]
  if (__FutureLite and (__FutureLite.VERSION < self.VERSION)) then
    ___FutureLite = self
    _G[GLOBAL_PATH] = self
  end
  return __FutureLite
end

--[[--
Check if the given value is callable.
@function FutureLite.isCallable
@tparam function|table
--]]
function FutureLite.isCallable(callable)
  if (type(callable) == "function") then return true end
  if (type(callable) == "table") then return (getmetatable(callable).__call ~= nil) end
  return false
end

--[[--
Ensure that the given value is callable.
@function FutureLite.checkisCallable
@tparam function|table
--]]
function FutureLite.checkIsCallable(callable)
  return (isCallable(callable) and callable) or notCallable(callable)
end

--[[---------------------------------------------------------------------------
@TODO(tullisar)
<summary>
<description>
@type CallbackList
------------------------------------------------------------------------------]]
CallbackList = __class()
FutureLite.CallbackList = CallbackList

--[[--
@TODO(tullisar)
<summary>
<description>
@function CallbackList:__new
--]]
function CallbackList:__new(...)
  local callbackList = { __callbacks = {}, __count = 0 }
  CallbackList.add(callbackList, ...)
  return callbackList
end

--[[--
@TODO(tullisar)
<summary>
<description>
@function CallbackList:addCallable
--]]
function CallbackList:__add(callback)
  self.__count = self.__count + 1
  self.__callbacks[self.__count] = FutureLite.checkIsCallable(callback)
end

--[[--
@TODO(tullisar)
<summary>
<description>
@function CallbackList:add
--]]
function CallbackList:add(...)
  for _,arg in __iterateArgs(...) do
    if (CallbackList:isInstance(arg)) then
      arg:forEach(|c| c:__add(arg))
    elseif (FutureLite.isCallable(arg)) then
      self:__add(arg)
    else
      __notCallable(arg)
    end
  end
end

--[[--
@TODO(tullisar)
<summary>
<description>
@function CallbackList:iterator
--]]
function CallbackList:iterator()
  return ipairs(self.__callbacks)
end

--[[--
@TODO(tullisar)
<summary>
<description>
@function CallbackList:forEach
--]]
function CallbackList:forEach(consumer)
  FutureLite.checkIsCallable(consumer)
  if (not self:isEmpty()) then
    for _,callback in self:iterator() do
      consumer(callback)
    end
  end
end

--[[--
@TODO(tullisar)
<summary>
<description>
@function CallbackList:__call
--]]
function CallbackList:__call(...)
  if (not self:isEmpty()) then
    for _,callback in self:iterator() do
      FutureLite.checkIsCallable(callback)(...)
    end
  end
end

--[[--
@TODO(tullisar)
<summary>
<description>
@function CallbackList:isEmpty
--]]
function CallbackList:isEmpty()
  return (self.__count == 0)
end

--[[---------------------------------------------------------------------------
@TODO(tullisar)
<summary>
<description>
@type Supplier
------------------------------------------------------------------------------]]
Supplier = __class()
FutureLite.Supplier = Supplier

--[[--
@TODO(tullisar)
<summary>
<description>
@function Supplier:__new
--]]
function Supplier:__new(value, isCallable)
  local supplier = {}
  if (Supplier:isInstance(value)) then
    supplier.__get = value.__get
  elseif (not (FutureLite.isCallable(value) or isCallable)) then
    supplier.__get = (|| value)
  else
    supplier.__get = value or __notCallable()
  end
  return supplier
end

--[[--
@TODO(tullisar)
<summary>
<description>
@function Supplier:__call
--]]
function Supplier:__call(errorHandler, packed)
  local get
  if (errorHandler and FutureLite.isCallable(errorHandler)) then
    get = || xpcall(|| self.__get(), errorHandler)
  else
    get = self.__get
  end
  return ((packed and table.pack(get())) or get())
end

--[[--
@TODO(tullisar)
<summary>
<description>
@type Future
--]]
Future = __class()
Future.__newIndex = __notModifiable
FutureLite.Future = Future

-- Define the possible states a future can be in.
local STATE = {
  NOT_STARTED = 1,
  PENDING     = 2,
  EXPIRED     = 3,
  SUCCESS     = 4,
  ERROR       = 5,
}

Future.STATE = STATE

------------------------------------------------------------------------------
-- Returns a new future instance prototype whose value is immediately
-- available.
------------------------------------------------------------------------------
local function __immediate(value)
  return {
    __isDone    = true,
    __state     = STATE.SUCCESS,
    __result    =
    {
      value = value,
      count = 1,
      get = (|r| value),
    },
  }
end

------------------------------------------------------------------------------
-- Returns a new future instance prototype whose value is queried from the
-- given supplier, and is considered done when the supplier returns a non-nil
-- value.
------------------------------------------------------------------------------
local function __delayed(supplier)

  supplier = (Supplier:isInstance(supplier) and supplier) or Supplier(supplier)

  -- Create a new future to hold the pending result.
  local future = {
    __isDone    = false,
    __timeout   = FutureLite.DEFAULT_TIMEOUT,
    __state     = STATE.NOT_STARTED,
    __result    = { count = 0 },
  }

  -- Get result by either returning a previously queried value if done, or
  -- by attempting to query the given supplier.
  function future.__result:get()

    if (not future.__isDone) then
      local results = supplier(future:error(), true)
      if (results[1] and (results[2] ~= nil)) then
        self.count = (results.n - 1)
        self.value = (((self.count > 1) and results) or results[2])
      end
    end

    -- Return the stored return value (if available). If there is more than one
    -- return value, unpack the table and return the elements.
    return ((self.count == 1) and self.value) or
           ((self.count > 1) and table.unpack(self.value, 2, (self.count + 1))) or nil

  end

  return future

end

--[[--
@TODO(tullisar)
<summary>
<description>
@function Future:__new
--]]
function Future:__new(result, isCallable)
  -- Create the future, either pending or immediate based on the provided
  -- arguments.
  local future
  if (FutureLite.isCallable(result) and (isCallable ~= false)) then
    future = __delayed(future, result, isCallable)
  else
    future = __immediate(result)
  end

  -- Initialise the callback list
  future.callbacks = {
    onTimeout = CallbackList(),
    onError   = CallbackList(),
    onSuccess = CallbackList(),
    isDone    = CallbackList(),
  }

  return future
end

--[[--
Registers a callback to run when the future expires while waiting for its result.
<summary>
<description>
@function Future:onTimeout
@tparam {Runnable,...}|CallbackList
--]]
function Future:onTimeout(...)
  if (not self.__isDone) then
    self.__callbacks.onTimeout:add(...)
  elseif (self.__state == STATE.EXPIRED) then
    CallbackList(...)()
  end
  return self
end

--[[--
Flags this future as expired.
<summary>
<description>
@function Future:expire
--]]
function Future:expire()
  if (not self.__isDone) then
    self.__isDone = true
    self.__state = STATE.EXPIRED
    self.__callbacks.onTimeout()
  end
  return self
end

--[[--
@TODO(tullisar)
<summary>
<description>
@function Future:onError
--]]
function Future:onError(...)
  if (not self.__isDone) then
    self.__callbacks.onError:add(...)
  elseif (self.__state == STATE.ERROR) then
    CallbackList(...)(self.__result.value)
  end
  return self
end

--[[--
@TODO(tullisar)
<summary>
<description>
@function Future:error
--]]
function Future:error()
  local future = self
  return function(error)
    if (not future.__isDone) then
      future.__isDone = true
      future.__state = STATE.ERROR
      future.__result.value = error
      future.__callbacks.onError(error)
    end
  end
end

--[[--
@TODO(tullisar)
<summary>
<description>
@function Future:onSucces
--]]
function Future:onSuccess(...)
  if (not self.__isDone) then
    self.__callbacks.onSuccess:add(...)
  elseif (self.__result.type == STATE.SUCCESS) then
    self.__callbacks.onSuccess(...)
  end
  return self
end

--[[--
@TODO(tullisar)
<summary>
<description>
@function <function>
--]]
function Future:testIsDone(...)
  if (not self.__isDone) then
    self.__callbacks.isDone:add(...)
  end
  return self
end

--[[--
@TODO(tullisar)
<summary>
<description>
@function Future:isDone
--]]
function Future:isDone()
  return (self.__isDone == true)
end

--[[--
@TODO(tullisar)
<summary>
<description>
@function Future:isFailed
--]]
function Future:isFailed()
  return (not ((self.__state == STATE.ERROR) or (self.__state == STATE.TIMEOUT)))
end

--[[--
@TODO(tullisar)
<summary>
<description>
@function Future:__test
--]]
function Future:__test()
  if (not self.__callbacks.isDone:isEmpty()) then
    for _,callback in self.__callbacks.isDone:iterator() do
      local success, isDone = xpcall(|| callback(), self:error())
      if not success then return false, true end
      if not isDone then return true, false end
    end
  end
end

--[[--
@TODO(tullisar)
<summary>
<description>
@function Future:__checkResult
--]]
function Future:__checkResult(ready, test)
  local isSuccess
  if (test and ready) then
    self.__result:get()
    isSuccess = (not self:isFailed())
  elseif (not test) then
    isSuccess = (self.__result:get() ~= nil) and (not self:isFailed())
  end
  if isSuccess then
    self.__isDone = true
    self.__state = STATE.SUCCESS
  end
end

--[[--
@TODO(tullisar)
<summary>
<description>
@function Future:test()
--]]
function Future:test()
  local future = self
  return function()
    if (not future.__isDone) then
      local ready, test = false, (not future.__callbacks.isDone:isEmpty())
      if (test) then
        local success, isDone = future:__test()
        ready = (success and isDone)
      end
      future:__checkResult(ready, test)
    end
    return future.__isDone
  end
end

--[[--
@TODO(tullisar)
<summary>
<description>
@function Future:done
--]]
function Future:done()
  local future = self
  return function()
    if ((future.__isDone) and (future.__results.type == STATE.SUCCESS)) then
      future.__callbacks.onSuccess(future.__results:get())
    end
  end
end

--[[--
@TODO(tullisar)
<summary>
<description>
@function Future:withTimeout
--]]
function Future:withTimeout(duration)
  if not self.__isDone then
    self.__timeout = ((type(duration) == "number") and duration) or error("Timeout value must be a number")
  end
  return self
end

--[[--
@TODO(tullisar)
<summary>
<description>
@function Future:submit
--]]
function Future:submit()
  local dispatch = FutureLite.dispatch
  if (not ((self.__isDone) or (self.__waitId))) then
    self.__waitId = dispatch(self:done(), self:test(), self.__timeout, self:timeout())
  end
end

return FutureLite
