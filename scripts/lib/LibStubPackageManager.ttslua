--[[
TODO(tullisar)
]]

#include LibStubCommon

local InstallPackageManager
do
  function InstallPackageManager(reinstall)

    local LibStub = RequireLibStub()

    local PACKAGE_SIGNATURE = "__bTUL_IsPackage"

    -- Initialize the package manager and metatable
    local setmetatable, getmetatable = _G.setmetatable, _G.getmetatable
    local tostring, tonumber = _G.tostring, _G.tonumber
    local type, error, assert = _G.type, _G.error, _G.assert

    -- All packages use the same metatable. Define the reference now.
    local Metatable = {}
    Metatable.__index = Metatable

    --[[
    Determines if the given object is a library package.

    @treturn boolean isPackage
    @treturn boolean isCompatible

    ]]
    local function IsPackage(package, version)

      -- Ensure that the version is a number if it is provided.
      if version then
        version = tonumber(version) or error("Version check requires valid version")
      end

      -- Check to see if the 'package' is actually a package
      local isPackage = (package and type(package) == "table" and package[PACKAGE_SIGNATURE])
      if ((not isPackage) or (not version)) then
        return isPackage, isPackage
      else
        return true, (version and (package.version >= version)) or true
      end
    end

    --[[
    Ensure that the provided object is a library package.
    ]]
    local function VerifyIsPackage(package)
      local isPackage = IsPackage(package)
      assert(isPackage)
    end

    --[[
    Validates a pcakage name.
    ]]
    local function ValidateName(name)
      return (name and tostring(name)) or error("Invalid Package Name")
    end

    --[[
    Validates a package version.
    ]]
    local function ValidateVersion(version)
      return (version and tonumber(version)) or error("Invalid Package Version")
    end

    --[[
    Dummy no-op function which is used to prevent modification of a package.
    ]]
    local function DoNothing(...)
      -- Intentionally empty
      return
    end

    --[[
    Returns a new top level package with the given version. Each package
    has its own metatable for encapsulating private data, and a shared metatable
    for shared methods.
    ]]
    function Metatable:NewPackage(name, version)

      -- Prototype table to be used as metatable for packages.
      local private =
      {
        name = ValidateName(name),
        version = ValidateVersion(version),
        children = {},
        modules = {},
        [PACKAGE_SIGNATURE] = true,
      }

      -- The private package table has the shared metatable set as its metatable,
      -- and is then set as the metatable for the new package.
      private.__index = private
      private.__newindex = DoNothing
      setmetatable(private, Metatable)
      return setmetatable({}, private)

    end

    --[[
    Returns a sub package within this package of the given name, optionally
    ensuring that the package is compatible with the given version.

    @treturn table? The package that was found

    ]]
    function Metatable:GetSubPackage(name, version)
      VerifyIsPackage(self)
      local package = self.children[name]
      local isPackage, isCompatible = IsPackage(package, version)
      package = (isPackage and isCompatible and package) or nil
      return package, isCompatible
    end

    --[[
    This function needs to be accessible to the entire script.
    ]]
    function Metatable:NewSubPackage(name, version, reinstall)
      local isPackage, isCompatible = IsPackage(self)


      -- Return any existing package with the given name if it's the same
      -- or newer version.
      local package, isCompatible = self:GetSubPackage(name, version)
      if (package and isCompatible and not reinstall) then
        return package
      end

      package = NewPackage(name, version)
      self.children[name] = package
      return package

    end

    function Metatable:GetModule(name, version)
      local isPackage, _ = IsPackage(self)


    end

    function Metatable:InstallModule(name, version, supplier, reinstall)



      local private =
      {
        name = ValidateName(name),
        version = ValidateVersion(version),
        [MODULE_SIGNATURE] = true,
      }

    end


    --[[
    Returns a new root package / package manager with the given name and version
    ]]
    function PackageManager(rootName, version)
      return Metatable:NewPackage(rootName, version)
    end

  end

end
