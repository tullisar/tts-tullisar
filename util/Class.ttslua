--[[--
@TODO(tullisar)
<summary>
<description>
@module <module>
@author Rob Bartlett-Schneider / Tullisar
@revision 0
@license Apache2
@copyright 2021 Rob Bartlett-Schneider
--]]

--------------------------------------------------------------------------------
-- Dependencies
--------------------------------------------------------------------------------
local Tables    = require("tts-tullisar.util.Tables")
local Strings   = require("tts-tullisar.util.Strings")
local Logger    = require("tts-tullisar.util.Logger")("Class")
local Functions = require("tts-tullisar.util.Functions")
Logger:setMinimumLevel(Logger.levels.TRACE)

--------------------------------------------------------------------------------
-- Class API
--------------------------------------------------------------------------------

local Class
do

  ------------------------------------------------------------------------------
  -- __argumentString
  -- Concatenates all of the given arguments to a single comma separated
  -- string, and converting all elements to strings in the process.
  ------------------------------------------------------------------------------
  local function __argumentString(...) --
    local args = table.pack(...)
    local argString = ""
    for i=1,args.n do
      argString = argString .. tostring(args[i]) .. (((i < args.n) and ",") or "")
    end
    return argString
  end

  local Static   = {} --
  local Meta     =
  {
    __index = function(_, property)
      return Static[property]
    end
  } --
  Class = setmetatable({}, Meta)
  local Registry = {}

  --[[--
  A table of reserved keys and properties. This table also uses an indexing
  metamethod to reserve names matching certain patterns. Queries to this
  table will always return a boolean.
  @table Reserved
  --]]
  local Reserved =
  { --
    __pattern       = "^___",
    ["new"]         = true,
    ["constructor"] = true,
    ["class"]       = true,
    ["static"]      = true,
    ["public"]      = true,

    -- LUA reserved keywords. Not sure if this is overkill, but I don't want
    -- it to come back cause issues later.
    ["and"]      = true,
    ["break"]    = true,
    ["do"]       = true,
    ["else"]     = true,
    ["elseif"]   = true,
    ["end"]      = true,
    ["false"]    = true,
    ["for"]      = true,
    ["function"] = true,
    ["goto"]     = true,
    ["if"]       = true,
    ["in"]       = true,
    ["local"]    = true,
    ["nil"]      = true,
    ["not"]      = true,
    ["or"]       = true,
    ["repeat"]   = true,
    ["return"]   = true,
    ["then"]     = true,
    ["true"]     = true,
    ["until"]    = true,
    ["while"]    = true,

  }
  setmetatable(Reserved,
  {
    -- Properties are reserved regardless of case, and for the moment all
    -- properties that begin with two underscores are reserved for future
    -- use. Properties that begin with only one or two underscores will never
    -- be treated as reserved by this module.
    __index = function(_, property) --
      Logger:trace("Reserved table __index[%s] access...", tostring(property))
      if (Strings:isString(property)) then
        Logger:trace("Checking lower case property name...")
        if (rawget(Reserved, property:lower()) == true) then return true end
        Logger:trace("Checking pattern match on property name...")
        if (property:match(Reserved.__pattern) ~= nil) then return true end
      end
      Logger:trace("Not a reserved property.")
      return false
    end
  })
  Tables:immutable(Reserved)

  ------------------------------------------------------------------------------
  -- A registry of all classes created by this module. Once created, a class
  -- type exists for the life of the scripting environment in which this module
  -- exists.
  ------------------------------------------------------------------------------
  do

    Registry.classes = --
    {
      byName     = {},
    }

    Registry.info =
    {
      byName  = {},
      byClass = {},
    }

    Registry.meta =
    {
      byClass = {},
    }

    ----------------------------------------------------------------------------
    -- __setClassProperty
    -- This is sued as the __newindex metamethod for a class type.
    ----------------------------------------------------------------------------
    local function __setClassProperty(class, property, value)
      Logger:trace("Attempting to set class property '%s=%s'...", tostring(property), type(value))
      local info = Registry:infoByClass(class)
      assert((not rawequal(class, value)), "Class cannot have a reference to itself")
      Strings:assertIsString(property, "Only string class properties are allowed.")
      Logger:trace("Checking reserved properties...")
      if (property == "new") then
        Logger:trace("Installing constructor....")
        assert(info.constructor == nil, "Constructor already exists.")
        info.constructor = Functions:assertIsCallable(value, "Constructor must be callable.")
        Logger:trace("Constructor installed...")
        return
      else
        assert(((Static[property] == nil) and (info.static[property] == nil)), "Cannot shadow a static property.")
        assert((not Reserved[property]), string.format("Cannot use reserved property '%s'.", property))
        Logger:trace("Setting public property.")
        info.public[property] = value
        Logger:trace("Property set.")
        return
      end
    end

    ----------------------------------------------------------------------------
    -- __getClassProperty
    -- This is used as the __index metamethod for a class type.
    ----------------------------------------------------------------------------
    local function __getClassProperty(class, property)
      Logger:trace("Attempting to get class property '%s'...", tostring(property))
      local info = Registry:infoByClass(class)
      Strings:assertIsString(property, "Only string class properties are allowed.")
      Logger:trace("Static table access?")
      if (property:lower() == "static") then return info.static end
      Logger:trace("Reserved property?")
      if (Reserved[property]) then return nil end
      Logger:trace("Class static property?")
      if (Static["___" .. property] ~= nil) then return Static["___" .. property] end
      Logger:trace("type static property?")
      if (info.static[property] ~= nil) then return info.static[property] end
      Logger:trace("type public property")
      return info.public[property]
    end

    ----------------------------------------------------------------------------
    -- __classForInstance
    ----------------------------------------------------------------------------
    local function __classForInstance(instance, quiet)
      local meta = assert((type(instance) == "table") and getmetatable(instance))
      local class = meta.__class
      local info = Registry:infoByClass(class, quiet)
      return ((info ~= nil) and class), info
    end


    --[[--
    Creats a new class in this registry and returns the "class" table, it's
    information table, and its metatable.
    @function Registry:new
    --]]
    function Registry:new(name)

      Logger:trace("Registering new class '%s'....", tostring(name))
      Strings:assertIsString(name, "Class name must be a string.")
      assert(not Strings:isBlank(name))
      assert(not self:classByName(name))

      local class = {}

      local meta  =
      {
        __index    = __getClassProperty,
        __newindex = __setClassProperty
      }

      local info =
      {
        name   = name,
        static = {},
        public =
        {
          class = __classForInstance
        }
      }

      setmetatable(class, meta)
      self.classes.byName[name] = class
      self.info.byName[name]    = info
      self.info.byClass[class]  = info
      self.meta.byClass[class]  = meta    -- TODO(tullisar): Needed?

      return class, meta, info

    end

    --[[--
    Finds class information by class table.
    @function Registry:infoByClass
    --]]
    function Registry:infoByClass(class, quiet)
      local info = self.info.byClass[class]
      assert((info ~= nil) or quiet)
      return info
    end

    --[[--
    @TODO(tullisar)
    <summary>
    <description>
    @function <function>
    --]]
    function Registry:forInstance(instance, quiet)
      return __classForInstance(instance, quiet)
    end

    --[[--
    Returns a class by the given name,
    @function Registry:classByName
    --]]
    function Registry:classByName(name)
      return self.classes.byName[name]
    end

  end

  ------------------------------------------------------------------------------
  -- Static methods/properties shared between the "Class" type, and all class
  -- types created by this module. Functions which are assigned to Static
  -- with "___funcName" can be called as methods on class types created from
  -- this module.
  ------------------------------------------------------------------------------
  do

    ----------------------------------------------------------------------------
    -- __setInstanceProperty
    -- Sets a value on an instance of the class.
    ----------------------------------------------------------------------------
    local function __setInstanceProperty(instance, property, value) --
      Logger:trace("Setting instance property '%s=%s'...", tostring(property), type(value))
      local class, info = Registry:forInstance(instance)
      assert((class ~= nil) and (property ~= nil))
      assert(((Static[property] == nil) and (info.static[property] == nil)), "Cannot shadow a static property.")
      assert(not Reserved[property], "Cannot set a reserved property.")
      local public = info.public[property]
      assert((public == nil) or (type(public) == type(value)), "Cannot change type of a public class property.")
      rawset(instance, property, value)
    end

    ----------------------------------------------------------------------------
    -- __getInstanceProperty
    -- This is used as the __index metamethod for a class instance.
    ----------------------------------------------------------------------------
    local function __getInstanceProperty(instance, property)
      local class, info = Registry:forInstance(instance)
      assert((class ~= nil) and (property ~= nil), "Unable to resolve class property: " .. tostring(property))
      local value = info.public[property]
      Logger:trace("%s.%s=%s", info.name, tostring(property), tostring(value))
      return value
    end

    ----------------------------------------------------------------------------
    -- __newInstance
    -- Returns a new instance of the given class.
    ----------------------------------------------------------------------------
    local function __newInstance(class, ...)
      local info = Registry:infoByClass(class)
      Logger:trace(string.format("%s:new(%s)", info.name, __argumentString(...)))
      Functions:assertIsCallable(info.constructor, "No constructor defined!")
      local instance = setmetatable({},
      {
        __index    = __getInstanceProperty, --
        __newindex = __setInstanceProperty,
        __class    = class,
      })
      info.constructor(class, instance, ...)
      return instance
    end

    ----------------------------------------------------------------------------
    -- __newClass
    ----------------------------------------------------------------------------
    local function __newClass(name, singleton)
      Logger:trace("Creating new class '%s'...", tostring(name))
      local class, meta, info = Registry:new(name)
      if (not singleton) then
        meta.__call = __newInstance
      end
      return class
    end

    --[[--
    Returns a new class type with the given name.
    @function Class:new
    --]]
    Static.new = |_, n, s| __newClass(n, s)
    Meta.__call = Static.new

    ----------------------------------------------------------------------------
    -- __isClass
    -- Free function helper for Static.isClass (see below).
    ----------------------------------------------------------------------------
    local function __isClass(class)
      local info = Registry:infoByClass(class, true)
      return (info ~= nil)
    end

    --[[--
    Determines if given value is a class type created by this module.
    @function Class:isClass
    --]]
    Static.isClass = |_, c| __isClass(c)

    ----------------------------------------------------------------------------
    -- __info
    -- Free function helper for Static.info (see below).
    ----------------------------------------------------------------------------
    local function __info(class)
      return Registry:infoByClass(class)
    end

    --[[--
    Returns the class information table for a class. This method is also
    callable on all class types created from this module (as class:info()).
    @function Class:info
    --]]
    Static.info   = |_, c| __info(c)
    Static.___info = __info

    ----------------------------------------------------------------------------
    -- __forInstance
    -- Free function helper for Static.forInstance (see below).
    ----------------------------------------------------------------------------
    local function __forInstance(instance)
      return Registry:forInstance(instance)
    end

    --[[--
    Determines if the given value is an instance of any class created by this
    module, and returns the class information if so.
    @function Class:forInstance
    --]]
    Static.forInstance = |_, i| __forInstance(i)

    ----------------------------------------------------------------------------
    -- __isInstance
    ----------------------------------------------------------------------------
    local function __isInstance(class, instance)
      local info = Registry:infoByClass(class)
      local __class, __info = Registry:forInstance(instance, true)
      return rawequal(class, __class)
    end

    --[[--
    Returns whether the given value is an instance of a provided class.
    @function Class:isInstance
    --]]
    Static.isInstance = |_,c,i| __isInstance(c, i)
    Static.___isInstance = __isInstance
  end

end

return Class
