--[[--
Futures API
@module Futures
@author Rob Bartlett-Schneider / Tullisar
@revision 1.0
@license Apache2
@copyright 2021 Rob Bartlett-Schneider
--]]

--------------------------------------------------------------------------------
-- Dependencies
--------------------------------------------------------------------------------
local Tables    = require("tts-tullisar.util.Tables")
local Functions = require("tts-tullisar.util.Functions")
local Logger    = require("tts-tullisar.util.Logger")("Futures")
local Class     = require("tts-tullisar.util.Class")

-- Create a new table for the library.
local Futures =
{
  DEFAULT_TIMEOUT = 45,
}

-- =============================================================================
-- Local functions
-- These are not exposed to users of this module.
-- =============================================================================

--------------------------------------------------------------------------------
-- __fps
-- Used to get the current number of frames per second, based on a running
-- average, dropping outliers.
--------------------------------------------------------------------------------
local __fps
do

  local __average = Time.delta_time --
  local __sum     = __average
  local __count   = 1

  ------------------------------------------------------------------------------
  -- __update
  -- Updates the current average FPS counter.
  -- @TODO(tullisar): Better outlier tracking.
  ------------------------------------------------------------------------------
  local function __update()
    local __current = Time.delta_time
    if ((__current < (2.0 * __average)) and (__current >= (0.5 * __average))) then
      __sum     = __sum + __current
      __count   = __count + 1.0
      __average = (__sum / __count);
    end
  end

  ------------------------------------------------------------------------------
  -- __fps
  -- Returns the current average frames per second.
  ------------------------------------------------------------------------------
  function __fps()
    local fps = (1.0 / __average)
  end

end

--------------------------------------------------------------------------------
-- __doCallbacks
-- Helper to execute all callbacks in the given list, using the provided
-- function to supply the arguments to the callbacks.
--------------------------------------------------------------------------------
function __doCallbacks(list, result)
  table.forEach(list, |callback| callback(result()))
end

local function __addToList(list, callback)
  assert(type(callback) == "function")
  list.n = list.n + 1
  list[list.n] = callback
end

local function __addCallbacks(list, ...)
  assert(type(list) == "table")
  table.forEachArgument(list, |callback| __addToList(list, callback)) --
end


--==============================================================================
-- Future API
--==============================================================================

--[[--
@TODO(tullisar)
@type Future
--]]
local Future
do

  -- Define the possible states a future can be in.
  local STATE = --
  {
    EXPIRED     = -3,
    CANCELLED   = -2,
    ERROR       = -1,
    NEW         = 0,
    READY       = 1,
    RUNNING     = 2,
    SUCCESS     = 4,
  }

  Future                = Class("tts-tullisar.Futures.Future")
  Future.Static.Builder = Class("tts-tullisar.Futures.Future.Builder")
  Future.STATE          = STATE
  local Builder         = Future.Static.Builder

  --[[--
  Constructs a new future.
  @function Future:new
  --]]
  function Future:new(future)
    future.__isDone  = false
    future.__state   = STATE.NEW
    future.__callbacks =
    {
      onTimeout = { n = 0 },
      onError   = { n = 0 },
      onSuccess = { n = 0 },
    }
    future.__result  = || error("Invalid future state.")
    future.__message = || error("Invalid future state.")
  end

  ------------------------------------------------------------------------------
  -- Future State Accessors
  ------------------------------------------------------------------------------
  Future.isFailed    = |f| (self.__state < STATE.NEW)
  Future.isCancelled = |f| (self.__state == STATE.CANCELLED)
  Future.isExpired   = |f| (self.__state == STATE.EXPIRED)
  Future.isError     = |f| (self.__state == STATE.ERROR)
  Future.isNew       = |f| (self.__state == STATE.NEW)
  Future.isReady     = |f| (self.__state == STATE.READY)
  Future.isRunning   = |f| (self.__state == STATE.RUNNING)
  Future.isSuccess   = |f| (self.__state == STATE.SUCCESS)
  Future.isDone      = |f| (f:isFailed() or f:isSuccess())

  ------------------------------------------------------------------------------
  -- Shared Functions
  ------------------------------------------------------------------------------

  --[[--
  Registers a callback to run when the future expires while waiting for its
  result. If this future is already complete and is expired, then the
  callback(s) will run immediately.
  @function Future:onTimeout
  --]]
  function Future:onTimeout(...)
    if (not self:isDone()) then
      __addCallbacks(self.__callbacks.onTimeout, ...)
    elseif (self:isExpired()) then
      __doCallbacks(self.__callbacks.onTimeout, || self:__message())
    end
    return self
  end
  Builder.onTimeout = (|b,...| b.__data:onTimeout(...) and b)

  --[[--
  Adds a timeout to this future of the given duration.
  @function Future:withTimeout
  --]]
  function Future:withTimeout(duration)
    if not self.__isDone then
      self.__timeout = ((type(duration) == "number") and (duration > 0) and duration) or error("Timeout value must be a number")
    end
    return self
  end
  Builder.withTimeout = (|b,d| b.__data:withTimeout(d) and b)

  --[[--
  Registers one or more callbacks to run when the future encounters an error
  while attempting to retrieve the result. If this future is already complete
  and has failed with an error, then the callback(s) will run immediately.    --
  @function Future:onError                                                    --
  --]]
  function Future:onError(...)
    if (not self:isDone()) then
      __addCallbacks(self.__callbacks.onError, ...)
    elseif (self:isError()) then
      __doCallbacks(self.__callbacks.onError, || self:__message())
    end
    return self
  end
  Builder.onError = (|b,...| b.__data:onError(...) and b)

  --[[--
  Registers one or more callbacks to run when this future has completed
  succesfully. If this future has already successfully completed, then the
  callback(s) will be run immediately.
  @function Future:onSucces
  --]]
  function Future:onSuccess(...)
    if (not self:isDone()) then
      __addCallbacks(self.__callbacks.onSuccess)
    elseif (self:isSuccess()) then
      __doCallbacks(self.__callbacks.onSuccess, || self:__result())
    end
    return self
  end
  Builder.onSucces = |b,...| (b.__data:onSuccess(...) and b)

  ------------------------------------------------------------------------------
  -- Builder Functions
  ------------------------------------------------------------------------------

  --[[--
  Returns a new future builder instance.
  @function Builder:new()
  --]]
  function Builder:new(builder)
    builder.__data = Future()
  end
  Future.Static.builder = |_, action| Builder(action)

  --[[--
  Builds and returns a new future using the details defined in this builder.
  @function Builder:build
  --]]
  function Builder:build(result, message)

    local data = self.__data
    local future = Future()
    future.__result    = Functions:assertIsCallable(result, "Invalid result supplier.")
    future.__message   = Functions:assertIsCallable(message, "Invalid message supplier.")
    future.__isDone    = false
    future.__timeout   = data.__timeout
    future.__state     = STATE.READY
    future.__callbacks =
    {
        onTimeout = table.copy(data.__callbacks.onTimeout), --
        onError   = table.copy(data.__callbacks.onError),
        onSuccess = table.copy(data.__callbacks.onSuccess),
    }

    return future

  end

  ------------------------------------------------------------------------------
  -- Future Functions
  ------------------------------------------------------------------------------

  --[[--
  Attempts to cancel this future, and prevent it from running if possible.
  @function Future:cancel
  --]]
  function Future:cancel(cancelRunning)
    if ((self:isRunning() and cancelIfRunning) or (self:isReady())) then
      self.__isDone = true
      self.__state  = STATE.CANCELLED
    end
    return (self.__state == STATE.CANCELLED)
  end

  --[[--
  Gets the result of this future, or throws the error that was encountered while
  attempting to compute the result.
  @function Future:get
  --]]
  function Future:get()
    assert(self:isDone(), "Result is not yet available.")
    if (self:isSuccess()) then
      return self:__result()
    elseif (self:isFailed()) then
      error(self:__message())
    end
  end

end

--[[--
Represents a runnable task managed by a scheduler, with a pending result.
@type Task
--]]
local Task
do
  Task = Class("Futures.Task") --

  --[[--
  Constructs a new task with the given action to run when the task is executed.
  @function Task:new
  --]]
  function Task:new(task, action)
    task.action = assert(Functions:isCallable(action) and action)
    local builder = Future:builder(action)
    task.future = builder:build(|| self:result(), || self:message())
    task.created = Time.time
    task.future.cancel = |_, c| self:cancel(c)
  end

  --[[--
  Cancels this task if possible.
  @function Task:cancel
  --]]
  function Task:cancel(cancelIfRunning)
    local cancelled = Future.cancel(self.future, cancelIfRunning)
    if (cancelled) then self.result.message = "Future was cancelled." end
  end

  --[[--
  Handles an error thrown while executing this tasks's action.
  @function Task:onError
  --]]
  function Task:onError(message)
    local message = string:format("[Task] Execution failed: \n%s", logString(message))
    Logger:error(message)
    if (not self.future:isDone()) then
      self.future.__isDone = true
      self.future.__state = Future.STATE.ERROR
      __doCallbacks(future.__callbacks.onError, || self:message())
    end
    return message
  end

  --[[--
  Proceses a timeout
  @function Task:onTimeout
  --]]
  function Task:onTimeout()
    if (not self.future:isDone()) then
      self.future.__isDone = true
      self.future.__state = Future.STATE.EXPIRED
      self.monitor = nil
      self.result.message = "Timed out while waiting for the result."
      Logger:trace("[Task] Timed out.")
      if (not Wait.stop(self.id)) then
        Logger:trace("[Task] Action: not stopped.")
      else
        Logger:trace("[Task] Action: stopped.")
        self.id = nil
      end
      __doCallbacks(self.future.__callbacks.onTimeout, || self:message())
    end
  end

  --[[--
  Determines if this task is done.
  @function Task:isDone
  --]]
  function Task:isDone()
    return self.future:isDone()
  end

  --[[--
  Checks that this task is complete, or throws an error.
  @function Task:assertIsDone
  --]]
  function Task:assertIsDone()
    assert(self:isDone(), "Invalid task state, task is not done.")
  end

  --[[--
  Checks that this task is complete, or throws an error.
  @function Task:assertIsDone
  --]]
  function Task:assertNotStarted()
    assert(self.future:isReady(), "Invalid task state, not in ready state.")
  end

  --[[--
  Returns the error message associated with this tasks's action, if any.
  @function Task:message
  --]]
  function Task:message()
    return self.result.message
  end

  --[[--
  Returns the result of this task, or throws an error if the task is failed.
  @function Task:result
  --]]
  function Task:result()
    self:assertIsDone()
    assert(self.future:isSuccess(), "Invalid task state, action was not successful.")
    local count = self.result.count
    local value = self.result.value
    return ((count == 1) and value) or
           ((count > 1) and table.unpack(value, 2, (count + 1))) or nil
  end

  --[[--
  Determines whether this task is expired or not.
  @function Task:isExpired
  --]]
  function Task:isExpired()
    if (not self.future:isDone()) then
      return ((Time.time - self.submitted) > self.future.__timeout)
    end
    return self.future:isExpired()
  end

  --[[--
  Starts a monitor for this tasks's comletion
  @function Task:monitorTimeout
  --]]
  function Task:monitorTimeout(started)
    assert((self.id ~= nil), "Invalid task state.")
    self.monitor = Wait.condition(|| self:onTimeout(), || self:isExpired() or self:isDone())
  end

  --[[--
  Runs this task's action and updates the future when the result is available.
  @function Task:run
  --]]
  function Task:run()

    -- Run the action in a protected call.
    self:assertNotStarted()
    local future = self.future
    future.__state = Future.STATE.RUNNING
    local results = table.pack(xpcall(|| self.action(), |e| self:onError(e)))
    future.__isDone = true

    -- Ensure the future is in a valid state after running. If failed, then
    -- state will already have been set by handlers, return early.
    if (future:isFailed()) then return end
    assert(results[1], "Invalid task state, action error not handled:\n" .. tostring(results[2]))

    -- Update state with results and notify callbacks.
    future.__state    = STATE.SUCCESS
    if (self.monitor) then Wait.stop(self.monitor) end
    self.result.count = (results.n - 1)
    self.result.value = (((self.result.count > 1) and results) or results[2])
    __doCallbacks(future.__callbacks.onSuccess, || self:result())


  end

end

-- =============================================================================
-- Schedulers API
-- =============================================================================
local Schedulers
do

  --[[--
  A factory of various scheduler implementations.
  @type Scheduler
  --]]
  Schedulers = Class("Futures.Scheduler", true)
  Futures.Schedulers = Schedulers

  --[[--
  Submit the given action to run later, and return a future representing the
  result of the action.
  @function Schedulers:submit
  --]]
  function Schedulers:submit(action)
    local task = Task(action)
    task.submitted = Time.time
    task.id = Wait.frames(task:run(), 1)
    task:monitorTimeout()
    return task.future
  end

  ----------------------------------------------------------------------------
  -- Task pool with limited locking mechanism. Locks are never called by
  -- functions, users of pool must use locks as appropriate.
  ----------------------------------------------------------------------------
  local Pool = Class("Futures.Schedulers.TaskPool")

  --[[--
  Creates a new task pool instance.
  @function Pool:new
  --]]
  function Pool:new(pool)
    pool.count  = 0
    pool.queue  = {}
    pool.swap   = {}
    pool.locked = 0
  end

  --[[--
  Checks to see if this pool has been locked.
  @function Pool:isLocked
  --]]
  function Pool:isLocked()
    return (self.locked > 0)
  end

  --[[--
  Locks the pool, and returns the current lock count.
  @function Pool:lock
  --]]
  function Pool:lock()
    self.locked = self.locked + 1
    return self.locked
  end

  --[[--
  Attempts to acquire the lock for this pool.
  @function Pool:tryLock
  --]]
  function Pool:tryLock()

    -- Check the lock for availability. Attempt to lock, then if lock count
    -- indicates contention, release the lock a variable number of frames
    -- from now.
    local locked = false
    if (not self:isLocked()) then
      locked = (self:lock() == 1)
      if (not locked) then Wait.frames(|| self:unlock(), math.random(2,6)) end
    end
    return locked
  end

  --[[--
  Releases a lock on this pool.
  @function Pool:unlock
  --]]
  function Pool:unlock()
    self.locked = self.locked - 1
  end

  --[[--
  Runs the given action for each item in this pool.
  @function Pool:forEach
  --]]
  Pool.forEach = |pool, action| table.forEachIndex(pool.queue, pool.count, action)

  --[[--
  Drains the contents of this pool's queue to another pool's queue.
  @function Pool:drainTo
  --]]
  function Pool:drainTo(other)
    assert(not rawequal(self, other), "Cannot drain to self.")
    assert(Pool:isInstance(other), "Can only drain to another pool.")
    self:forEach(|index, task| (other:add(self.queue[index]) and rawset(self.queue[index], nil)))
    self.count = 0
  end

  --[[--
  Adds the given task to this pool.
  @function Pool:add
  --]]
  function Pool:add(task)
    assert(Task:isInstance(task), "Only a scheduler task may be added.")
    self.count = self.count + 1
    self.queue[self.count] = task
  end

  --[[--
  Cleans this pool up, shifting elements up as needed.
  @function Pool:clean
  --]]
  function Pool:clean()
    local queue = self.queue
    local count = 0
    for i=1,self.count do
      if (queue[i] == nil) then
        for j=(i+1),self.count do
          if (queue[j] ~= nil) then
            queue[i] = queue[j]
            queue[j] = nil
          end
        end
      end
      if (queue[i] == nil) then break end
      count = count + 1
    end
    self.count = count
  end

  ------------------------------------------------------------------------------
  -- Unbounded Scheduler
  ------------------------------------------------------------------------------
  local Unbounded = Class("Futures.Schedulers.Unbounded")
  Schedulers.unbounded = (|| Unbounded())
  do

    local Monitor = Class("Futures.Schedulers.Unbounded.Monitor") --
    Monitor.DELAY = 0.1

    local STATE =
    {
      NEW     = 0,
      POLLING = 1,
      RUNNING = 2,
    }

    ----------------------------------------------------------------------------
    -- Define monitor polling rates.
    ----------------------------------------------------------------------------
    local POLL
    do
      POLL = --
      {
        FAST   = { LIMIT = 1.0,  WAIT = Wait.frames, DUR = || math.random(1,3)            , DESC = "fast"},
        NORMAL = { LIMIT = 5.0,  WAIT = Wait.frames, DUR = || math.random(3,10)           , DESC = "normal"},
        MEDIUM = { LIMIT = 10.0, WAIT = Wait.time,   DUR = || math.random() + 1.0         , DESC = "medium"},
        SLOW   = { LIMIT = 60.0, WAIT = Wait.time  , DUR = || (math.random() * 4.0) + 1.0 , DESC = "slow"},
      }
      local p
      for _, r in pairs(POLL) do
        r.delay = |a| r.WAIT(a, r.DUR())
        if p then p.NEXT = r end
        p = r
      end
      POLL.SLOW.NEXT = NORMAL
    end

    --[[--
    Creates a new queue monitor for the unbounded scheduler.
    @function Monitor:new
    --]]
    function Monitor:new(monitor, tasks)
      monitor.waiting  = tasks.waiting
      monitor.active   = tasks.active
      monitor.done     = tasks.done
      monitor.state    = STATE.NEW
      monitor.rate     = POLL.FAST
    end --

    --[[--
    Ensures that this monitor is ready for use.
    @function Monitor:assertReady()
    --]]
    function Monitor:assertReady()
      assert(self.id == nil, "Invalid monitor state, monitor already running.")
    end

    --[[--
    Ensures that the monitor is running a task and is in the given state.
    @function Monitor:assertState
    --]]
    function Monitor:assertState(state)
      assert((self.id ~= nil) and (self.state == state), "Invalid monitor state, current state is not expected.")
    end

    --[[--
    Delays the given action by an amount determined by the monitor's current
    polling rate.
    @function Monitor:delay
    --]]
    function Monitor:delay(action)
      self:assertReady()
      self.id = self.rate.delay(action)
    end

    --[[--
    Checks to see if there are any tasks in the waiting pool and if the lock
    is currently available.
    @function Monitor:hasWaiting
    @return boolean|number false if there are no tasks waiting, otherwise the
            number of tasks is returned. --
    --]] --
    function Monitor:hasWaiting()
      assert(self.waiting.count >= 0, "Unexpected monitor state (negative task count).")
      local count = self.waiting.count
      if ((count > 0) and (not self.waiting:isLocked())) then
        return count
      else
        return false
      end
    end

    ----------------------------------------------------------------------------
    -- __offer
    -- Offers a task to the given monitor.
    --------------------------------------------------------------------------------
    function __offer(monitor, task)
      Logger:trace("[Monitor] Delay: offer()")
      monitor.rate = POLL.FAST
      monitor:delay(|| monitor:offer(runnable, task))
      return task
    end

    --[[--
    Offers the given task to this monitor's waiting queue, or retrying until
    successful.
    @function Monitor:offer
    --]]
    function Monitor:offer(task)
      Logger:trace("[Monitor] offer()")
      self:assertReady()
      if (self.waiting:tryLock()) then
        Logger:trace("[Monitor] Lock: acquired.")
        self.waiting:add(task)
        Logger:trace("[Monitor] Task: added.")
      else
        Logger:trace("[Monitor] Lock: busy.")
        __offer(monitor, task)
      end
    end

    ----------------------------------------------------------------------------
    -- __poll
    -- Logs and delays a polling action.
    ----------------------------------------------------------------------------
    local function __poll(monitor)
      monitor.state = STATE.POLLING
      Logger:trace("[Monitor] Delay: poll()...")
      monitor:delay(|| monitor:poll())
    end

    --[[--
    Polls for waiting tasks in this monitor's waiting task pool.
    @function Monitor:poll
    --]]
    function Monitor:poll()
      Logger:trace("[Monitor] poll()")
      self:assertState(STATE.POLLING)
      self.id = nil
      local waiting = self:hasWaiting()
      if (waiting) then
        Logger:trace("[Monitor] Waiting tasks: " .. tostring(waiting) .. ".")
        if (self.waiting:tryLock()) then
          Logger:trace("[Monitor] Lock: acquired.")
          self.serviced = Time.time
          self.rate = POLL.FAST
          self.state = STATE.RUNNING
          Logger:trace("[Monitor] Delay: run()...")
          self:delay(|| self:run())
          return
        else
          Logger:trace("[Monitor] Lock: busy.")
        end
      else
        Logger:trace("[Monitor] Waiting tasks: false.")
        local serviced = (self.serviced or Time.time)
        if ((Time.time - serviced) > self.rate.LIMIT) then
          Logger:trace("[Monitor] Rate limit reached: " .. self.rate.DESC .. ".")
          self.rate = (self.rate.NEXT or self.rate)
        end
      end
      __poll(self)
    end

    --[[--
    Moves waiting tasks into the active pool, starts them, and then checks
    for the completion of any tasks in the pool.
    @function Monitor:run --
    --]]
    function Monitor:run()
      Logger:trace("[Monitor] run()")
      self:assertState(STATE.RUNNING)
      Logger:trace("[Monitor] Draining waiting tasks")
      self.waiting:drainTo(active)
      self.waiting:unlock()
      Logger:trace("[Monitor] Checking task states.")
      self.active:forEach(|i,t| self:check(i, t))
      Logger:trace("[Monitor] Cleaning up.")
      self.active:clean()
      self.id = nil
      __poll(self)
    end

    --[[--
    Starts this monitor and periodically checks for waiting tasks.
    @function Monitor:start
    --]]
    function Monitor:start()
      Logger:trace("[Monitor] Starting task monitor.")
      assert(self.state == STATE.NEW, "Invalid monitor state, this monitor has already been started.")
      self.started = Time.time
      __poll(self)
    end

    --[[--
    Executs the given task, and sets up a monitor for the task's completion.
    @function Monitor:execute
    --]]
    function Monitor:execute(task)
      assert((task.id == nil), "Invalid monitor state, task is already active.")
      task.id = self.rate.delay(task.run)
    end

    --[[--
    Checks the task at the given index for whether it needs to be executed or
    has finished and needs to be cleaned up.
    @function Monitor:check
    --]]
    function Monitor:check(index, task)

      -- Execute the task if it hasn't been started
      if (task.id == nil) then
        self:execute(task)
      end

      -- Check if the task is done, and clear the it from the active pool.
      -- Move it to the done pool afterwards.
      if (task.done) then
        self.active.queue[index] = nil
        self.done:add(task)
      end

    end

  end

end

return Futures
